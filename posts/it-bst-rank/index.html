<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="ko"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="[자료구조] 이진 탐색 트리 Rank" /><meta name="author" content="dapin1490" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="Trust me I’m a talking potato" /><meta property="og:description" content="Trust me I’m a talking potato" /><link rel="canonical" href="https://dapin1490.github.io/satinbower-legacy/posts/it-bst-rank/" /><meta property="og:url" content="https://dapin1490.github.io/satinbower-legacy/posts/it-bst-rank/" /><meta property="og:site_name" content="새틴바우어" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-09-29T23:55:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[자료구조] 이진 탐색 트리 Rank" /><meta name="twitter:site" content="@dapin1490" /><meta name="twitter:creator" content="@dapin1490" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"dapin1490"},"dateModified":"2022-09-29T23:55:00+09:00","datePublished":"2022-09-29T23:55:00+09:00","description":"Trust me I’m a talking potato","headline":"[자료구조] 이진 탐색 트리 Rank","mainEntityOfPage":{"@type":"WebPage","@id":"https://dapin1490.github.io/satinbower-legacy/posts/it-bst-rank/"},"url":"https://dapin1490.github.io/satinbower-legacy/posts/it-bst-rank/"}</script><title>[자료구조] 이진 탐색 트리 Rank | 새틴바우어</title><link rel="apple-touch-icon" sizes="180x180" href="/satinbower-legacy/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/satinbower-legacy/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/satinbower-legacy/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/satinbower-legacy/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/satinbower-legacy/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="새틴바우어"><meta name="application-name" content="새틴바우어"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/satinbower-legacy/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/satinbower-legacy/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/satinbower-legacy/" class="mx-auto"> <img src="/satinbower-legacy/assets/img/profile_image.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/satinbower-legacy/">새틴바우어</a></div><div class="site-subtitle font-italic">dapin1490's hand-made study blog</div></div><ul class="w-100"><li class="nav-item"> <a href="/satinbower-legacy/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>홈</span> </a><li class="nav-item"> <a href="/satinbower-legacy/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>카테고리</span> </a><li class="nav-item"> <a href="/satinbower-legacy/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>태그</span> </a><li class="nav-item"> <a href="/satinbower-legacy/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>아카이브</span> </a><li class="nav-item"> <a href="/satinbower-legacy/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>정보</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/dapin1490" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/dapin1490" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['dapin1490','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/satinbower-legacy/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/satinbower-legacy/"> 홈 </a> </span> <span>[자료구조] 이진 탐색 트리 Rank</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 포스트</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> </span> <span id="search-cancel" >취소</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4 pb-5"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[자료구조] 이진 탐색 트리 Rank</h1><div class="post-meta text-muted"> <span> 게시 <em class="" data-ts="1664463300" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2022-09-29 </em> </span><div class="d-flex justify-content-between"> <span> By <em> dapin1490 </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5193 단어"> <em>28 분</em>읽는 시간</span></div></div></div><div class="post-content"><style> .x-understand { color: #ccb833; } .understand { color: #1380da; } .tab { white-space: pre; } .underline { text-decoration: underline; }</style><h1 id="과제">과제</h1><pre><code class="language-txt">아래 내용을 포함하는 포트폴리오를 작성하고, 웹페이지 주소를 제출합니다.
1. Data structures augmentation 코딩
- Rank 구현
- AVL tree 구현
2. AVL tree 정의 등 강의 내용 정리
*Geeks for geeks 참조하세요.
https://www.geeksforgeeks.org/avl-tree-set-1-insertion/
https://www.geeksforgeeks.org/avl-tree-set-2-deletion/
3. Leet code 문제 풀이
https://leetcode.com/problems/balanced-binary-tree/
</code></pre><h1 id="목차">목차</h1><ol><li>Data structures augmentation<li>Rank 구현<ol><li>원래 예시 코드에서 달라진 점<li>노드 클래스<li>탐색 메소드<li>삽입 메소드<li>삭제 메소드<li>Rank 메소드</ol></ol><h2 id="다음-글"><span class="mr-2">다음 글</span><a href="#다음-글" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://dapin1490.github.io/satinbower/posts/it-avl-tree/" target="_blank">[자료구조] 균형 이진 트리, AVL 트리</a></p><p><br /></p><hr /><p><br /></p><h1 id="data-structures-augmentation">Data structures augmentation</h1><p><strong>Data structures augmentation</strong> : 데이터 구조가 효율적으로 구현될 수 있도록 기존 데이터 구조에 몇 가지 추가 정보를 추가하는 것을 의미한다<sup>[<a id="body-cite-1" href="#ref-cite-1" title="Augmenting Data Structure">1</a>]</sup>. <a href="https://dapin1490.github.io/satinbower/posts/it-bin-search-tree/" target="_blank" title="[자료구조] Big-O와 이진 탐색 트리">지난 글</a>에서는 트리에서 각 노드가 갖는 자손 노드의 수를 노드 클래스의 멤버 변수로 추가하여 특정 값보다 크거나 작은 값의 개수를 구하는 메소드를 구현했는데, 이것이 Data structures augmentation 자료구조 증강에 해당한다. 편의상 앞으로는 자료구조 증강이라 부르겠다.</p><h1 id="rank-구현">Rank 구현</h1><p>이진 탐색 트리는 모든 탐색을 루트에서부터 시작하고, 루트에서 수많은 가지로 뻗어나가는 형태이기 때문에 특정 범위의 값에 대한 연산이 곤란한 경우가 있다. 어떤 값보다 큰 요소의 개수, 작은 요소의 개수를 구하는 문제가 이런 문제이다. 이를 해결하기 위해 이진 탐색 트리의 각 노드에 자기 자신을 포함해 해당 노드가 갖는 자손 노드의 수를 멤버 변수로서 함께 저장할 수 있다. 코드는 <a href="https://dapin1490.github.io/satinbower/posts/it-bin-search-tree/" target="_blank" title="[자료구조] Big-O와 이진 탐색 트리">지난번</a>에 이미 보여주긴 했지만 이번엔 내가 그 코드를 구상한 과정을 설명해보겠다.</p><p><a id="bodylink-ghcode" href="https://github.com/dapin1490/satinbower/tree/main/assets/files/code/countBST.cpp" target="_blank" title="countBST.cpp">전체 코드 깃허브에서 보기</a><br /> <a href="https://ideone.com/PCGu4u" target="_blank" title="countBST.cpp 실행 결과 보기">코드 실행 결과 보기</a></p><h2 id="원래-예시-코드에서-달라진-점"><span class="mr-2">원래 예시 코드에서 달라진 점</span><a href="#원래-예시-코드에서-달라진-점" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://github.com/dapin1490/satinbower/tree/main/assets/files/code/BSTexample.cpp" target="_blank" title="BSTexample.cpp">원래 예시 코드 깃허브에서 보기</a><br /> <a href="https://ideone.com/ORGQ01" target="_blank" title="BSTexample.cpp 실행 결과 보기">코드 실행 결과 보기</a></p><p>원래 예시 코드에는 노드 클래스에 멤버 변수만 있고 모든 메소드가 트리 클래스에 있었다. 노드 클래스의 멤버 변수가 public으로 선언되었기 때문에 getter나 setter도 없이 모든 변수에 직접 접근했었다. 내가 Rank를 구현하기 위해 코드를 바꾸기 시작하면서, 이 변수들에 직접 접근하는 건 실수의 여지가 많다고 생각해서 getter와 setter를 만들고 멤버 변수는 모두 private으로 바꿨다. 하는 김에 생성자도 추가했는데 이건 필요해서 했다기보다는 내가 허전해서 만들었다. 어쨌든 일단은 이게 첫 번째이다.</p><p>두 번째는 재귀로 구현된 대부분 메소드를 반복문으로 바꿨다는 것이다. 루트에서 특정 노드까지 따라가면서 자손 노드의 수를 세도록 만들 계획이었는데, 재귀로 해서는 개수가 제대로 세어지지 않을 게 뻔했기 때문에 최대한 재귀를 없애야 했다. 그 결과 삭제 메소드와 중위순회 메소드를 제외한 모든 메소드를 반복으로 구현할 수 있었다. 삭제 메소드는 한번에 모든 과정을 반복으로 구현하려다가 포인터를 다루는 부분에서 오류가 났고, 그것을 내 힘으로 고치지 못하는 문제가 있었지만, 약간의 과정을 추가하여 해당 오류를 피하고 재귀를 유지하면서 구현할 수 있었다. 이에 대한 설명은 삭제 메소드를 설명할 때 하겠다. 덧붙여, 중위순회 메소드는 카운트 변수를 함께 출력한다는 점 이외에는 바꿀 것이 없었기 때문에 설명하지 않는다.</p><h2 id="노드-클래스"><span class="mr-2">노드 클래스</span><a href="#노드-클래스" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>가장 기본적으로 각 노드가 자신을 포함한 자손 노드의 수를 저장할 수 있어야 한다. 편의상 카운트 변수라고 부르자. 자기자신을 포함하기 때문에 리프노드라도 기본값은 1에서 시작한다. 이 값은 생성자에는 포함하지 않았고 멤버 변수 선언에서부터 초기화했다. 카운트 변수는 자주 증감연산을 할 수 있고, 보통은 1 단위로 증감하기 때문에 외부에서 불 때 구분하기 쉽도록 증감 메소드를 따로 만들었다.</p><p>카운트 변수 이외에도 다양한 getter와 setter를 추가했고, 해당 노드가 리프노드인지 확인하는 메소드도 추가했다. 리프노드 확인 메소드는 삭제 연산에서 사용한다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">node</span> <span class="p">{</span>
<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
  <span class="n">node</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span>
  <span class="n">node</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">public:</span>
  <span class="n">node</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="n">node</span><span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="n">node</span><span class="o">*</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="o">~</span><span class="n">node</span><span class="p">()</span> <span class="p">{}</span>

  <span class="kt">int</span> <span class="nf">getData</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">node</span><span class="o">*</span> <span class="nf">getLeft</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">left</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">node</span><span class="o">*</span> <span class="nf">getRight</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">right</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="nf">getcnt</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">cnt</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">setLeft</span><span class="p">(</span><span class="n">node</span><span class="o">*</span> <span class="n">le</span><span class="p">)</span> <span class="p">{</span> <span class="n">left</span> <span class="o">=</span> <span class="n">le</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">setRight</span><span class="p">(</span><span class="n">node</span><span class="o">*</span> <span class="n">ri</span><span class="p">)</span> <span class="p">{</span> <span class="n">right</span> <span class="o">=</span> <span class="n">ri</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">upcnt</span><span class="p">()</span> <span class="p">{</span> <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">downcnt</span><span class="p">()</span> <span class="p">{</span> <span class="n">cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">setData</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span> <span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">bool</span> <span class="nf">isLeaf</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="탐색-메소드"><span class="mr-2">탐색 메소드</span><a href="#탐색-메소드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>탐색을 재귀에서 반복으로 바꾸는 것은 쉽다. 재귀 호출이 있던 부분을 모두 서브트리로 이동하는 것으로 바꾸고, 탐색의 모든 과정을 while 반복문 안에 넣으면 된다. 탐색이 끝나면 결과를 바로 return한다. 특정 값을 찾는 탐색은 트리를 전혀 조작하지 않기 때문에 카운트 변수와는 상관이 없다. public 메소드와 private 메소드가 따로 구현된 것은 원래의 예시 코드를 그대로 따랐다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="nl">private:</span>
  <span class="n">node</span><span class="o">*</span> <span class="nf">find_impl</span><span class="p">(</span><span class="n">node</span><span class="o">*</span> <span class="n">current</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// private 탐색 메소드</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 현재 탐색하는 노드가 NULL인 경우</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"No matching value found for "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">".</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">()</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 원하는 값 찾음</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">" has been found.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">current</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// 원하는 값이 더 작음</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"current is "</span> <span class="o">&lt;&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">". pointer moved to left.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getLeft</span><span class="p">();</span> <span class="c1">// 왼쪽 서브트리로 이동</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span> <span class="c1">// 위의 모든 선택문을 패스했다면 원하는 값이 더 큰 경우임</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"current is "</span> <span class="o">&lt;&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">". pointer moved to right.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getRight</span><span class="p">();</span> <span class="c1">// 오른쪽 서브트리로 이동</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">node</span><span class="o">*</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 특정 값 탐색 메소드</span>
    <span class="k">return</span> <span class="n">find_impl</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span> <span class="c1">// 따로 구현된 private 탐색 메소드 호출</span>
  <span class="p">}</span>
</pre></table></code></div></div><h2 id="삽입-메소드"><span class="mr-2">삽입 메소드</span><a href="#삽입-메소드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>탐색 메소드와 같은 방식으로 하나의 큰 while문 안에 코드를 모두 넣고, 서브트리로 이동하는 코드만 재귀에서 포인터 이동으로 바꾸었다. 주의해야 할 점은 트리를 조작하는 메소드이기 때문에 카운트 변수도 같이 다루어야 한다는 것이다. 삽입 연산이니 새 노드가 추가되는 자리에 따라 그 조상 노드는 모두 카운트 변수가 1씩 증가해야 한다.</p><p>삽입 연산은 방향이 정해져 있어 되돌아가는 일이 없으니 루트부터 매번 노드를 이동해 반복을 시작할 때마다 카운트 변수를 먼저 1씩 증가시키고 삽입 연산을 수행하도록 했다. public으로 정의된 함수는 크게 바꾸지 않았다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="nl">private:</span>
  <span class="kt">void</span> <span class="nf">insert_impl</span><span class="p">(</span><span class="n">node</span><span class="o">*</span> <span class="n">current</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// private 삽입 메소드</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">current</span><span class="o">-&gt;</span><span class="n">upcnt</span><span class="p">();</span> <span class="c1">// 노드가 삽입되는 경로를 따라 카운트 증가</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// 삽입할 값이 현재 탐색하는 노드보다 작음</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">getLeft</span><span class="p">()</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 왼쪽 서브트리 없음</span>
          <span class="n">current</span><span class="o">-&gt;</span><span class="n">setLeft</span><span class="p">(</span><span class="k">new</span> <span class="n">node</span><span class="p">{</span> <span class="n">value</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">});</span> <span class="c1">// 바로 붙임</span>
          <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"current is "</span> <span class="o">&lt;&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">" is inserted left</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
          <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span> <span class="c1">// 왼쪽 서브트리 있음</span>
          <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getLeft</span><span class="p">();</span> <span class="c1">// 왼쪽 서브트리로 이동</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span> <span class="c1">// else: 삽입할 값이 현재 탐색하는 노드보다 크거나 같음</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">getRight</span><span class="p">()</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 오른쪽 서브트리 없음</span>
          <span class="n">current</span><span class="o">-&gt;</span><span class="n">setRight</span><span class="p">(</span><span class="k">new</span> <span class="n">node</span><span class="p">{</span> <span class="n">value</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">});</span> <span class="c1">// 바로 붙임</span>
          <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"current is "</span> <span class="o">&lt;&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">" is inserted right</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
          <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span> <span class="c1">// else: 오른쪽 서브트리 있음</span>
          <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getRight</span><span class="p">();</span> <span class="c1">// 오른쪽 서브트리로 이동</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 삽입 메소드</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 루트가 비어있다면</span>
      <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">node</span><span class="p">{</span> <span class="n">value</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="nb">nullptr</span> <span class="p">};</span> <span class="c1">// 루트에 바로 넣음</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">" is inserted into root</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="c1">// else: 루트가 비어있지 않다면</span>
      <span class="n">insert_impl</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span> <span class="c1">// 따로 구현된 private 삽입 메소드 호출</span>
  <span class="p">}</span>
</pre></table></code></div></div><h2 id="삭제-메소드"><span class="mr-2">삭제 메소드</span><a href="#삭제-메소드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>삭제 메소드는 원래 private 메소드에서 모든 과정을 수행하고 public 메소드는 private 메소드를 호출하는 역할만 갖고 있었지만, 카운트 변수를 조작하는 과정을 추가하면서 원래 private 메소드가 수행하던 일부 과정을 public 메소드가 수행하게 되었다.</p><p>우선 삭제의 과정을 간단히 정리해보자.<br /> (1) 삭제할 노드를 찾는다.<br /> <span class="tab">    </span>(1.1) 삭제할 노드가 없으면 NULL을 반환하고 종료.<br /> (2) 삭제할 노드가 서브트리를 얼마나 갖고 있는지 검사한다.<br /> <span class="tab">    </span>(2.1) 서브트리가 없다면 노드 삭제 후 오른쪽 서브트리를 반환하며 결과적으로 NULL이 반환된다.<br /> <span class="tab">    </span>(2.2) 한쪽 서브트리만 있다면 노드 삭제 후 해당 서브트리의 포인터를 반환한다.<br /> (3) 삭제할 노드에 양쪽 서브트리가 다 있다면 후계자를 찾아 삭제할 노드의 데이터를 후계자의 것으로 대체한다.<br /> (4) 후계자로 쓰인 노드를 삭제하기 위해 원래 <span class="underline">삭제할 노드의 오른쪽 서브트리</span>에서부터 다시 1번 과정을 시작한다. 이때 원래 삭제하려고 했던 노드와 후계자 노드가 모두 같은 값을 갖고 있는 상태이기 때문에 트리 내의 키가 중복되어 삭제할 노드를 잘못 찾는 문제를 방지하기 위해 오른쪽 서브트리에서 탐색을 시작한다.</p><p>나는 위의 과정 중 노드가 가진 서브트리의 수를 검사하고 후계자를 선출해 대체하는 부분을 public 메소드로 옮기고, private 메소드에는 순수하게 목표한 노드를 찾아가 삭제하는 과정만 남겼다. 그리고 두 가지 메소드로 분리된 그 과정들의 사이에 카운트 변수를 업데이트하는 메소드를 새로 정의해 호출하였다. 카운트 변수를 업데이트하는 메소드는 탐색 메소드와 유사하지만, 목표한 노드가 반드시 있음을 전제로 하고 경로상의 모든 노드의 카운트 변수를 1씩 감소시켜야 한다는 차이가 있다. 목표한 노드가 반드시 있다는 것은 이 메소드를 호출하기 전 탐색 메소드를 통해 확인함으로써 보장한다.</p><p>메소드의 개수만 해도 4개가 하나의 작업을 위해 쓰이고, 이중 내가 수정하거나 만든 것이 3개이기 때문에 이 부분 코드가 좀 길다. 후계자 노드를 찾는 메소드는 수정하지 않았으므로 아래 코드블록에 포함하지 않는다. 전체 코드는 <a href="#bodylink-ghcode">여기</a>에서 볼 수 있다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
</pre><td class="rouge-code"><pre><span class="nl">private:</span>
  <span class="n">node</span><span class="o">*</span> <span class="nf">delete_impl</span><span class="p">(</span><span class="n">node</span><span class="o">*</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// private 특정 값 삭제 메소드</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"current node is "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">start</span> <span class="o">?</span> <span class="n">to_string</span><span class="p">(</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">())</span> <span class="o">:</span> <span class="s">"NULL"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">".</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 현재 노드가 NULL</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"No value matches "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">".</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// 삭제한 노드 없음, NULL 반환</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">())</span> <span class="c1">// 삭제할 값이 현재 노드보다 작음</span>
      <span class="n">start</span><span class="o">-&gt;</span><span class="n">setLeft</span><span class="p">(</span><span class="n">delete_impl</span><span class="p">(</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">getLeft</span><span class="p">(),</span> <span class="n">value</span><span class="p">));</span> <span class="c1">// 왼쪽 서브트리에 삭제 메소드 다시 호출</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">())</span> <span class="c1">// else if: 삭제할 값이 현재 노드보다 큼</span>
      <span class="n">start</span><span class="o">-&gt;</span><span class="n">setRight</span><span class="p">(</span><span class="n">delete_impl</span><span class="p">(</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">getRight</span><span class="p">(),</span> <span class="n">value</span><span class="p">));</span> <span class="c1">// 오른쪽 서브트리에 삭제 메소드 다시 호출</span>
    <span class="k">else</span> <span class="p">{</span> <span class="c1">// else: 삭제할 값이 현재 노드와 같음</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">getLeft</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// 왼쪽 서브트리가 없음</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"there is no left subtree. bring the right subtree.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">getRight</span><span class="p">();</span> <span class="c1">// 현재 노드의 오른쪽 서브트리를 가져옴</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"delete "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">".</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">start</span><span class="p">;</span> <span class="c1">// 현재 노드를 지움</span>
        <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span> <span class="c1">// 아까 가져온 오른쪽 서브트리 반환</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">getRight</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// 오른쪽 서브트리가 없음</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"there is no right subtree. bring the left subtree.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">getLeft</span><span class="p">();</span> <span class="c1">// 현재 노드의 왼쪽 서브트리 가져옴</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"delete "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">".</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">start</span><span class="p">;</span> <span class="c1">// 현재 노드를 지움</span>
        <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span> <span class="c1">// 아까 가져온 왼쪽 서브트리 반환</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">start</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">recount</span><span class="p">(</span><span class="n">node</span><span class="o">*</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 노드 삭제를 위해 누적 노드 개수를 수정하는 메소드</span>
    <span class="n">node</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span> <span class="c1">// 루트에서 시작</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 현재 탐색하는 노드가 NULL인 경우</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"error: No matching value found for "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">".</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span> <span class="c1">// 끝</span>
      <span class="p">}</span>

      <span class="n">current</span><span class="o">-&gt;</span><span class="n">downcnt</span><span class="p">();</span> <span class="c1">// 현재 노드의 카운트 감소</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// 원하는 값이 더 큼</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"current is "</span> <span class="o">&lt;&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">". pointer moved to right.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getRight</span><span class="p">();</span> <span class="c1">// 오른쪽 서브트리로 이동</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// 원하는 값이 더 작음</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"current is "</span> <span class="o">&lt;&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">". pointer moved to left.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getLeft</span><span class="p">();</span> <span class="c1">// 왼쪽 서브트리로 이동</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/*
      원하는 값 찾음:
      후계자가 선정되어 값이 바뀌었거나 값이 같은 노드가 중복하여 존재하는 경우,
      삭제할 노드를 헷갈리지 않기 위해 객체 자체를 비교함
      */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" has been found.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// 원래 삭제하려던 노드의 후계자가 대신 삭제되어야 하는 경우</span>
      <span class="c1">// data는 같지만 노드 자체는 달라서 위의 선택문을 모두 통과하는 경우가 있음</span>
      <span class="c1">// 그럴 때는 후계자 선정 규칙에 따라 오른쪽 서브트리로 이동</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"current is "</span> <span class="o">&lt;&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">". pointer moved to right.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
      <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getRight</span><span class="p">();</span> <span class="c1">// 오른쪽 서브트리로 이동</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="nf">deleteValue</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 특정 값 삭제</span>
    <span class="n">node</span><span class="o">*</span> <span class="n">del_node</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">value</span><span class="p">);</span> <span class="c1">// 삭제할 노드 찾기</span>
    <span class="n">node</span><span class="o">*</span> <span class="n">succ</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">del_node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 삭제할 노드가 있다면</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">del_node</span><span class="o">-&gt;</span><span class="n">getLeft</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">del_node</span><span class="o">-&gt;</span><span class="n">getRight</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 후계 필요</span>
        <span class="n">succ</span> <span class="o">=</span> <span class="n">successor</span><span class="p">(</span><span class="n">del_node</span><span class="p">);</span> <span class="c1">// 후계 선정</span>
        <span class="n">recount</span><span class="p">(</span><span class="n">succ</span><span class="p">);</span> <span class="c1">// 노드 삭제를 위해 누적 노드 개수를 수정하는 메소드</span>
        <span class="n">del_node</span><span class="o">-&gt;</span><span class="n">setData</span><span class="p">(</span><span class="n">succ</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">());</span> <span class="c1">// 삭제할 노드의 데이터를 후계의 데이터로 대체</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">setRight</span><span class="p">(</span><span class="n">delete_impl</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">getRight</span><span class="p">(),</span> <span class="n">succ</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">()));</span> <span class="c1">// 후계 노드 삭제</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span> <span class="c1">// 후계 필요 없음</span>
        <span class="n">recount</span><span class="p">(</span><span class="n">del_node</span><span class="p">);</span> <span class="c1">// 노드 삭제를 위해 누적 노드 개수를 수정하는 메소드</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">delete_impl</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span> <span class="c1">// private 삭제 메소드 호출</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span> <span class="c1">// 삭제할 노드가 없음</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"delete error: No value matches "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">".</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span> <span class="c1">// 돌아감</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></table></code></div></div><h2 id="rank-메소드"><span class="mr-2">Rank 메소드</span><a href="#rank-메소드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>지금까지 여러 메소드들을 개조한 이유는 Rank 메소드를 구현하기 위해서였다. 다시 한 번 설명하자면 Rank 메소드는 트리에서 이진 탐색 트리에서 특정 값보다 크거나 작은 값의 개수를 세는 메소드를 말한다. 나는 key로 주어진 값보다 큰 것의 개수와 작은 것의 개수를 세는 메소드를 구현했다. 두 메소드는 서로 방향만 다를 뿐 과정은 동일하니 큰 값의 개수를 세는 메소드를 기준으로 설명하겠다. 코드블록에도 큰 값을 세는 메소드만 보여주겠지만 삭제 메소드에서와 마찬가지로 전체 코드는 <a href="#bodylink-ghcode">여기</a>에서 볼 수 있다.</p><p>Rank를 구하는 과정은 다음과 같다. key 값보다 큰 것의 개수를 세는 과정을 기준으로 하며, <strong>트리에 중복된 값이 저장되어 있을 수 있음을 전제로 한다</strong>. 중복을 불허한다면 과정은 더 단순해질 수 있다.</p><p>(1) 우선 key와 같은 값을 가진 노드를 찾을 때까지 탐색을 시작한다.<br /> (2) key와 다른 값을 가진 노드가 나왔다면 다음을 수행한다.<br /> <span class="tab">    </span>(2.1) key보다 큰 값을 찾았다면 해당 노드를 개수에 포함하기 위해 +1을 하고, 오른쪽 서브트리가 있다면 오른쪽 자손의 수도 같이 더한다. 이후 왼쪽 서브트리로 이동한다.<br /> <span class="tab">    </span>(2.2) key보다 작은 값을 찾았다면 오른쪽 서브트리로 이동한다.<br /> (3) key와 같은 값을 찾았다면 오른쪽 서브트리로 이동한다.<br /> (4) NULL에 도달할 때까지 (2)의 과정을 반복한다.<br /> (5) NULL에 도달했다면 지금까지 센 개수를 반환한다.</p><p>작은 값을 세는 메소드는 위의 과정에서 좌우를 바꾸면 된다.</p><p>참고를 위해, 중복을 불허한 트리의 Rank 구현 과정도 보자.<br /> (1) 원하는 값을 찾을 때까지 내려가면서<br /> (2) 자기 자신보다 작거나 같으면 or 크거나 같으면 +1,<br /> (3) 해당 노드의 왼쪽 or 오른쪽 자손 노드의 개수도 더한다.<br /> (4) 원하는 노드를 찾으면 해당 노드의 자신을 포함한 자손 노드의 개수를 세고 끝낸다.</p><p>아래 코드는 key보다 큰 값의 개수를 세는 메소드이다. 클래스 외부에서 사용할 수 있어야 하기 때문에 public으로 정의되었다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">countGreater</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 특정 값(key)보다 큰 요소의 개수 셈</span>
  <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">node</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 반복 탐색</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"current value is "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="n">to_string</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">())</span> <span class="o">:</span> <span class="s">"NULL"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="c1">// 더 탐색할 노드가 없음</span>
      <span class="k">break</span><span class="p">;</span> <span class="c1">// 반복 종료</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// key와 같은 값 찾음</span>
      <span class="c1">// 오른쪽에 더 큰 값이 남아있을 수 있으므로 오른쪽으로 이동</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"find key value. go right.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
      <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getRight</span><span class="p">();</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// key보다 큰 값 찾음</span>
      <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 일단 현재 노드를 카운트에 추가</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">getRight</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="c1">// 오른쪽 서브트리가 있다면</span>
        <span class="n">cnt</span> <span class="o">+=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getRight</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getcnt</span><span class="p">();</span> <span class="c1">// 오른쪽 서브트리의 노드 수도 추가</span>

      <span class="c1">// 왼쪽에 더 큰 값이 남아있을 수 있으므로 왼쪽으로 이동</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"current value "</span> <span class="o">&lt;&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" is greater than key value. add right count and go left</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
      <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getLeft</span><span class="p">();</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// key보다 작은 값 찾음</span>
      <span class="c1">// 오른쪽에 더 큰 값이 남아있을 수 있으므로 오른쪽으로 이동</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"current value "</span> <span class="o">&lt;&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getData</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" is lesser than key value. Don't add count and go right</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
      <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">getRight</span><span class="p">();</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">cnt</span><span class="p">;</span> <span class="c1">// 반복 종료 후 결과 반환</span>
<span class="p">}</span>
</pre></table></code></div></div><p><br /></p><hr /><p><br /></p><h1 id="참고-자료">참고 자료</h1><p>[<a id="ref-cite-1" href="#body-cite-1">1</a>] Augmenting Data Structure <a href="https://www.includehelp.com/data-structure-tutorial/augmenting-data-structure.aspx" target="_blank" title="Augmenting Data Structure">https://www.includehelp.com/data-structure-tutorial/augmenting-data-structure.aspx</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/satinbower-legacy/categories/it/'>IT</a>, <a href='/satinbower-legacy/categories/data-structure/'>Data Structure</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/satinbower-legacy/tags/%EC%A7%80%EC%8B%9D/" class="post-tag no-text-decoration" >지식</a> <a href="/satinbower-legacy/tags/it/" class="post-tag no-text-decoration" >IT</a> <a href="/satinbower-legacy/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/" class="post-tag no-text-decoration" >자료구조</a> <a href="/satinbower-legacy/tags/%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC/" class="post-tag no-text-decoration" >이진 탐색 트리</a> <a href="/satinbower-legacy/tags/%EA%B3%BC%EC%A0%9C/" class="post-tag no-text-decoration" >과제</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.ko"> CC BY-NC-ND 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%5B%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%5D+%EC%9D%B4%EC%A7%84+%ED%83%90%EC%83%89+%ED%8A%B8%EB%A6%AC+Rank+-+%EC%83%88%ED%8B%B4%EB%B0%94%EC%9A%B0%EC%96%B4&url=https%3A%2F%2Fdapin1490.github.io%2Fsatinbower-legacy%2Fposts%2Fit-bst-rank%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/satinbower-legacy/posts/backend-internet-230704/">[Backend] 인터넷이 뭔데</a><li><a href="/satinbower-legacy/posts/it-boj-1254/">[python] 백준 1254 팰린드롬 만들기</a><li><a href="/satinbower-legacy/posts/py-exe-release/">[python] GUI 프로그램 exe 만들고 배포하기, 소멸자와 로깅</a><li><a href="/satinbower-legacy/posts/daily-230617/">23년 1학기 14주 수업</a><li><a href="/satinbower-legacy/posts/chatgpt-230103/">Unity vs Unreal Engine</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/satinbower-legacy/tags/%EC%A7%80%EC%8B%9D/">지식</a> <a class="post-tag" href="/satinbower-legacy/tags/it/">IT</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%82%B4%EA%B0%80-%ED%95%B4%EB%83%84/">내가 해냄</a> <a class="post-tag" href="/satinbower-legacy/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/">문제풀이</a> <a class="post-tag" href="/satinbower-legacy/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> <a class="post-tag" href="/satinbower-legacy/tags/%EA%B3%BC%EC%A0%9C/">과제</a> <a class="post-tag" href="/satinbower-legacy/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/">프로젝트</a> <a class="post-tag" href="/satinbower-legacy/tags/leetcode/">LeetCode</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/">딥러닝</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/satinbower-legacy/posts/it-bin-search-tree/"><div class="card-body"> <em class="small" data-ts="1663940100" data-df="YYYY-MM-DD" > 2022-09-23 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[자료구조] Big-O와 이진 탐색 트리</h3><div class="text-muted small"><p> 과제 아래 내용을 포함하는 포트폴리오를 작성하고, 웹페이지 주소를 제출합니다. 1. 스케줄링 문제에 접근하는 이진 탐색 트리 소개(필수) (-&amp;gt; 응답시간 대기시간 등등 말하는 것 같음. &quot;좋은 스케줄링은 프로세서의 효율성을 높이고, 프로세스의 응답시간을 최소화하여 시스템의 작업 처리 능력을 향상시킨다.&quot;) 2. Big-O 소개(선택) 3. 문...</p></div></div></a></div><div class="card"> <a href="/satinbower-legacy/posts/it-data-structure-binary-search-tree/"><div class="card-body"> <em class="small" data-ts="1662457260" data-df="YYYY-MM-DD" > 2022-09-06 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[자료구조] 이진 탐색 트리</h3><div class="text-muted small"><p> 참고자료 &amp;lt;C++로 쉽게 풀어쓴 자료구조&amp;gt; 천인국, 최영규 지음, 생능 출판사 공부 범위 : 챕터 9 이진 탐색 트리 이진 탐색 트리 탐색이란? 탐색 : 레코드(record)의 집합에서 특정한 레코드를 찾아내는 작업 레코드(record) : 하나 이상의 필드(field)로 구성된다 테이블(table) : 레코드의 집합 키(key)...</p></div></div></a></div><div class="card"> <a href="/satinbower-legacy/posts/it-priority-queue-heap/"><div class="card-body"> <em class="small" data-ts="1663157580" data-df="YYYY-MM-DD" > 2022-09-14 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[자료구조] 우선순위 큐와 힙</h3><div class="text-muted small"><p> 과제 우선순위 큐와 힙 내용 정리, C++를 이용한 우선순위큐 프로그래밍 방법 정리 백준 1966번 프린터 큐 풀이(필수) 백준 1655번 가운데를 말해요 풀이(선택) 우선순위 큐와 힙 내용 정리 힙도 자료구조다 힙 heap : 트리의 형태로 표현됨. 트리 : 사이클이 없는 그래프. 참고 : [자료구조] 트리, 참고 : [...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/satinbower-legacy/posts/it-bin-search-tree/" class="btn btn-outline-primary" prompt="이전 글"><p>[자료구조] Big-O와 이진 탐색 트리</p></a> <a href="/satinbower-legacy/posts/daily-220930/" class="btn btn-outline-primary" prompt="다음 글"><p>22.09.30 cold and hot</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/dapin1490">dapin1490</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY-NC-ND 4.0) 라이선스에 따라 사용이 허가되었습니다.">일부 권리 보유</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/satinbower-legacy/tags/%EC%A7%80%EC%8B%9D/">지식</a> <a class="post-tag" href="/satinbower-legacy/tags/it/">IT</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%82%B4%EA%B0%80-%ED%95%B4%EB%83%84/">내가 해냄</a> <a class="post-tag" href="/satinbower-legacy/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/">문제풀이</a> <a class="post-tag" href="/satinbower-legacy/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> <a class="post-tag" href="/satinbower-legacy/tags/%EA%B3%BC%EC%A0%9C/">과제</a> <a class="post-tag" href="/satinbower-legacy/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/">프로젝트</a> <a class="post-tag" href="/satinbower-legacy/tags/leetcode/">LeetCode</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/">딥러닝</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">새 버전의 콘텐츠를 사용할 수 있습니다.</p><button type="button" class="btn btn-primary" aria-label="Update"> 업데이트 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/satinbower-legacy/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/satinbower-legacy/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/satinbower-legacy/app.js"></script>
