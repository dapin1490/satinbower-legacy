<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="ko"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="[자료구조] BFS와 DFS" /><meta name="author" content="dapin1490" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="Trust me I’m a talking potato" /><meta property="og:description" content="Trust me I’m a talking potato" /><link rel="canonical" href="https://dapin1490.github.io/satinbower-legacy/posts/it-bfs-and-dfs/" /><meta property="og:url" content="https://dapin1490.github.io/satinbower-legacy/posts/it-bfs-and-dfs/" /><meta property="og:site_name" content="새틴바우어" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-11-07T00:22:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[자료구조] BFS와 DFS" /><meta name="twitter:site" content="@dapin1490" /><meta name="twitter:creator" content="@dapin1490" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"dapin1490"},"dateModified":"2022-11-07T00:22:00+09:00","datePublished":"2022-11-07T00:22:00+09:00","description":"Trust me I’m a talking potato","headline":"[자료구조] BFS와 DFS","mainEntityOfPage":{"@type":"WebPage","@id":"https://dapin1490.github.io/satinbower-legacy/posts/it-bfs-and-dfs/"},"url":"https://dapin1490.github.io/satinbower-legacy/posts/it-bfs-and-dfs/"}</script><title>[자료구조] BFS와 DFS | 새틴바우어</title><link rel="apple-touch-icon" sizes="180x180" href="/satinbower-legacy/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/satinbower-legacy/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/satinbower-legacy/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/satinbower-legacy/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/satinbower-legacy/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="새틴바우어"><meta name="application-name" content="새틴바우어"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/satinbower-legacy/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/satinbower-legacy/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/satinbower-legacy/" class="mx-auto"> <img src="/satinbower-legacy/assets/img/profile_image.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/satinbower-legacy/">새틴바우어</a></div><div class="site-subtitle font-italic">dapin1490's hand-made study blog</div></div><ul class="w-100"><li class="nav-item"> <a href="/satinbower-legacy/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>홈</span> </a><li class="nav-item"> <a href="/satinbower-legacy/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>카테고리</span> </a><li class="nav-item"> <a href="/satinbower-legacy/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>태그</span> </a><li class="nav-item"> <a href="/satinbower-legacy/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>아카이브</span> </a><li class="nav-item"> <a href="/satinbower-legacy/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>정보</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/dapin1490" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/dapin1490" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['dapin1490','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/satinbower-legacy/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/satinbower-legacy/"> 홈 </a> </span> <span>[자료구조] BFS와 DFS</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 포스트</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> </span> <span id="search-cancel" >취소</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4 pb-5"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[자료구조] BFS와 DFS</h1><div class="post-meta text-muted"> <span> 게시 <em class="" data-ts="1667748120" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2022-11-07 </em> </span><div class="d-flex justify-content-between"> <span> By <em> dapin1490 </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4256 단어"> <em>23 분</em>읽는 시간</span></div></div></div><div class="post-content"><style> .x-understand { color: #ccb833; } .understand { color: #1380da; } .tab { white-space: pre; } .underline { text-decoration: underline; } figure { text-align: center; }</style><h2 id="할-일"><span class="mr-2">할 일</span><a href="#할-일" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><pre><code class="language-txt">이번 숙제는 다음 내용을 포함합니다.
1. 그래프 예시를 직접 만듭니다. (O)
2. BFS와 DFS 알고리즘을 바탕으로 그래프 탐색 과정을 그립니다. (O)
3. 본인이 편하게 사용할 수 있는 BFS와 DFS 코드를 작성합니다. (O)
4. (옵션) BFS 관련 문제를 풀어 봅니다. (X)

DFS 관련 문제는 금일 시간 관계 상 다루지 못하였기 때문에 다음 주에 다룹니다. 

평가(총 6점)
3점: 독자 입장에서 평가 대상 수강생의 포트폴리오를 읽고, BFS 과정을 쉽게 이해할 수 있는지
3점: 독자 입장에서 평가 대상 수강생의 포트폴리오를 읽고, DFS 과정을 쉽게 이해할 수 있는지
보너스 점수 항목:
첫째. BFS와 DFS의 차이점을 알 수 있는지
둘째. BFS 관련 문제 풀이를 통해 알고리즘을 적용해 보았는지
</code></pre><h2 id="목차"><span class="mr-2">목차</span><a href="#목차" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>그래프<li>BFS 알고리즘과 코드<li>DFS 알고리즘과 코드 - 미완성<li>BFS와 DFS의 시각적 비교</ol><h2 id="그래프"><span class="mr-2">그래프</span><a href="#그래프" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>그래프(graph) G=(V, E)는 유한한 개수의 정점(vertex) 또는 노드(node)들의 집합인 V와 연결선(edge) 또는 에지라고 불리는 정점들의 쌍들의 집합인 E로 이루어진다.[<a id="body-ref-01" href="#tail-ref-01" title="『4차 산업혁명 시대의 이산수학』, 김대수 지음, 생능출판">1</a>]</p></blockquote><p>쾨니히스베르크 다리 문제(<a href="https://ko.wikipedia.org/wiki/%EC%BE%A8%EB%8B%88%ED%9E%88%EC%8A%A4%EB%B2%A0%EB%A5%B4%ED%81%AC%EC%9D%98_%EB%8B%A4%EB%A6%AC_%EB%AC%B8%EC%A0%9C">위키백과</a>)를 들어본 적이 있다면 금방 이해할 수 있을 것이다. 프로그래밍에서 말하는 그래프는 엑셀에 그리는 것과 같은 그래프가 아니고, 선으로 연결된 점들의 집합이다.</p><p>그래프는 크게 방향이 있는 것과 방향이 없는 것으로 나눌 수 있다. 보통 그래프라고 하면 방향이 없는 그래프를 의미하며 방향이 있는 그래프는 <strong>방향 그래프(directed graph)</strong> 또는 <strong>다이그래프(digraph)</strong>라고 따로 지칭한다. 이때 간선은 아크(arc)라고 말한다.[<a id="body-ref-01-2" href="#tail-ref-01" title="『4차 산업혁명 시대의 이산수학』, 김대수 지음, 생능출판">1</a>] 이 글에서도 그래프라고 하면 기본적으로 방향이 없는 그래프를 지칭한다. 덧붙여, 트리도 그래프의 일종이다. 자세한 것은 참고 자료 1번의 책을 공부하자.</p><p>그래프의 예시는 아래와 같다. 이후에 BFS와 DFS를 설명할 때에도 사용할 그래프이니 잘 봐두자.</p><figure id="img-01"> <img data-src="/satinbower-legacy/assets/img/category-it/221106-1-graph.jpg" data-proofer-ignore><figcaption>[이미지 1] 그래프 예시</figcaption></figure><h2 id="bfs-알고리즘과-코드"><span class="mr-2">BFS 알고리즘과 코드</span><a href="#bfs-알고리즘과-코드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>BFS는 Breadth First Search의 약자로 너비 우선 탐색이라고 한다. 특정한 시작점에서 출발하여, 그 점에서 가장 가까운 점부터 차례대로 방문한다. 시작점을 중심으로 동심원을 그려나간다고 생각하면 이해하기 좋다. 매번 정점을 방문할 때마다 다음에 방문할 정점을 저장해두고 저장한 순서대로 방문하기 때문에, 이 알고리즘을 수행할 때는 큐를 사용하는 것이 적절하다. 그리고 비선형 구조를 탐색하는 것이기 때문에 한 번 탐색한 곳을 다시 탐색하지 않는 것이 중요하다. 이를 위해 방문한 정점의 배열을 따로 만들어 사용한다.</p><p>이 알고리즘을 정리하면 다음과 같다.</p><pre><code class="language-txt">시작점을 큐에 넣고, 방문했음을 표시한다.
이후의 과정을 큐가 비어있을 때까지 반복한다:
    큐에서 요소를 하나 pop하고 방문했음을 표시한다.
    방금 pop한 것에 대하여 방문하지 않은 정점만 큐에 push한다.
</code></pre><p>[<a href="#img-01">이미지 1</a>]을 예시로 BFS 탐색을 수행해보자. 시작점은 1이고 거리가 같은 정점이 여러 개 있을 때는 숫자가 작은 것부터 방문한다고 가정한다.</p><ol><li>탐색을 시작하기 전, 방문해야 할 정점을 저장할 빈 큐와 모든 정점의 방문 여부가 false로 표기된 방문 정점 리스트를 준비한다. 이 리스트는 배열을 써도 좋고, 벡터를 써도 좋다.<ul><li>큐의 내용 : <code class="language-plaintext highlighter-rouge">(비어있음)</code><li>방문 정점 리스트 : <code class="language-plaintext highlighter-rouge">{ 0, 0, 0, 0, 0, 0, 0, 0, 0 }</code> <em>// 편의상 true/false 대신 1/0으로 표기하며, 인덱스는 1부터 시작한다.</em></ul><li>탐색을 시작한다. 가장 먼저 시작점인 1을 큐에 넣고 방문했음을 표시한다.<ul><li>큐의 내용 : <code class="language-plaintext highlighter-rouge">{ 1 }</code><li>방문 정점 리스트 : <code class="language-plaintext highlighter-rouge">{ 0, 0, 0, 0, 0, 0, 0, 0, 0 }</code></ul><li>큐에 저장된 것을 하나 꺼낸다. 2번에서 1을 큐에 넣었으므로 1이 나온다. 1과 인접한 정점들을 큐에 차례대로 넣는다. 여기서는 2와 3을 넣으면 된다.<ul><li>큐의 내용 : <code class="language-plaintext highlighter-rouge">{ 2, 3 }</code><li>방문 정점 리스트 : <code class="language-plaintext highlighter-rouge">{ 1, 0, 0, 0, 0, 0, 0, 0, 0 }</code></ul><li>큐에 저장된 것을 하나 꺼내고(2가 나온다), 아직 방문하지 않은 정점이므로 해당 정점을 방문한 것으로 표시한다.<ul><li>큐의 내용 : <code class="language-plaintext highlighter-rouge">{ 3 }</code><li>방문 정점 리스트 : <code class="language-plaintext highlighter-rouge">{ 1, 1, 0, 0, 0, 0, 0, 0, 0 }</code></ul><li>2와 인접한 정점들 중 방문하지 않은 것들을 큐에 차례대로 넣는다. 4, 5가 큐에 들어간다.<ul><li>큐의 내용 : <code class="language-plaintext highlighter-rouge">{ 4, 5 }</code><li>방문 정점 리스트 : <code class="language-plaintext highlighter-rouge">{ 1, 1, 0, 0, 0, 0, 0, 0, 0 }</code></ul><li>위의 과정을 더이상 방문할 정점이 없을 때까지 수행한다.</ol><p>[<a href="#img-01">이미지 1</a>]의 그래프를 위와 같은 과정으로 탐색하면 방문하는 노드의 순서는 <code class="language-plaintext highlighter-rouge">{ 1, 2, 3, 4, 5, 6, 7, 8, 9 }</code>이다. 그림으로 그리면 아래와 같다. 노란색, 초록색, 파란색, 보라색 영역 내에 있는 정점을 순서대로 방문한다.</p><figure id="img-02"> <img data-src="/satinbower-legacy/assets/img/category-it/221106-2-graph.jpg" data-proofer-ignore><figcaption>[이미지 2] BFS 예시</figcaption></figure><p>코드로 구현해보자. 위에 서술된 알고리즘과는 약간 다른 부분이 보일 수 있는데, BFS 알고리즘을 이용해 시작점(station)을 기준으로 시작점과 각 정점 간의 거리를 구하는 코드이다. 인접한 정점 간의 거리는 모두 1로 전제한다. 또한 cout을 이용한 출력 대신 별도의 텍스트파일에 결과를 쓰도록 했다. cout으로 실행하고 싶다면 <code class="language-plaintext highlighter-rouge">output_file</code>을 모두 cout으로 바꿔쓰면 된다. 전체 코드는 <a href="https://github.com/dapin1490/satinbower/blob/main/assets/files/code/BFS_DFS.h" target="_blank">깃허브</a>에서 볼 수 있으며, 교수님의 코드를 참고하여 내 방식대로 작성한 것이다. 전체 코드의 길이가 길어 아래 코드는 일부 생략하고 작성했다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">to_station</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span> <span class="c1">// 가장 가까운 station까지의 거리</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">adj</span><span class="p">;</span> <span class="c1">// 인접 노드</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// 각 인접 노드까지의 거리</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Graph</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">vertices</span><span class="p">;</span> <span class="c1">// 점 수</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">graph</span><span class="p">;</span> <span class="c1">// 각 노드의 키값은 벡터의 인덱스로 대체</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">;</span> <span class="c1">// 방문 여부</span>

    <span class="kt">void</span> <span class="n">print_route</span><span class="p">();</span> <span class="c1">// BFS로 탐색 후 탐색 결과를 출력함</span>

<span class="nl">public:</span>
    <span class="n">Graph</span><span class="p">(</span><span class="kt">int</span> <span class="n">vts</span><span class="p">);</span> <span class="c1">// 생성자</span>

    <span class="kt">void</span> <span class="n">BFS</span><span class="p">(</span><span class="kt">int</span> <span class="n">start_key</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">BFS</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">starts</span><span class="p">);</span> <span class="c1">// station이 여러 개일 경우 사용, 코드는 생략</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">Graph</span><span class="o">::</span><span class="n">BFS</span><span class="p">(</span><span class="kt">int</span> <span class="n">start_key</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 루트(시작점)에서 시작</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">que</span><span class="p">;</span>
    <span class="n">graph</span><span class="p">[</span><span class="n">start_key</span><span class="p">].</span><span class="n">to_station</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 시작점은 station이므로 station까지의 거리가 0</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">start_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 방문 표시 후</span>
    <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">start_key</span><span class="p">);</span> <span class="c1">// 큐에 push</span>

    <span class="n">output_file</span> <span class="o">&lt;&lt;</span> <span class="s">"----------</span><span class="se">\n</span><span class="s">Station : "</span> <span class="o">&lt;&lt;</span> <span class="n">start_key</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">Search by BFS</span><span class="se">\n\n</span><span class="s">"</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// 큐가 비어있을 때까지</span>
        <span class="n">start_key</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="c1">// 큐에서 하나 pop</span>
        <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">start_key</span><span class="p">].</span><span class="n">adj</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 방금 pop한 노드의 인접한 노드에 대해 방문하지 않은 것에 한해 큐에 push</span>
            <span class="kt">int</span> <span class="n">current</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">start_key</span><span class="p">].</span><span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">current</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">current</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
                <span class="n">graph</span><span class="p">[</span><span class="n">current</span><span class="p">].</span><span class="n">to_station</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">start_key</span><span class="p">].</span><span class="n">to_station</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 지금 방문한 곳은 station으로부터 현재의 기준점보다 1만큼 더 떨어져 있음</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 탐색을 끝낸 후 방문 여부 표시를 모두 지움</span>
    <span class="n">visited</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

    <span class="c1">// 탐색 결과 출력</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">print_route</span><span class="p">();</span>
    <span class="n">output_file</span> <span class="o">&lt;&lt;</span> <span class="s">"----------</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="dfs-알고리즘과-코드"><span class="mr-2">DFS 알고리즘과 코드</span><a href="#dfs-알고리즘과-코드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>DFS는 Depth First Search의 약자로 깊이 우선 탐색이라고 한다. 특정한 시작점에서 출발하여, 그 점에서 갈 수 있는 가장 깊은 점부터 차례대로 방문한다. 미로에서 출구를 찾을 때의 풀이 과정을 생각하면 된다. 보통 사람은 동시에 여러 통로를 볼 수 없기 때문에, 하나의 통로를 쭉 따라가 그것의 끝이 막혔는지 확인하고, 막혔다면 되돌아와 다른 갈림길로 들어가 같은 과정을 반복하는 방식으로 미로를 탐색한다. 이것이 DFS의 방식이다. 더이상 갈 곳이 없을 때까지 나아간 후, 되돌아 나오면서 등장하는 갈림길에서 다시 가장 깊은 곳으로 들어가는 것을 반복하여 탐색한다. DFS는 나아간 길을 되돌아올 수 있어야 하기 때문에 재귀나 스택을 사용하는 게 적절하다. BFS와 마찬가지로 한 번 방문한 곳을 다시 방문하지 않는 것이 중요하다.</p><p>이 알고리즘을 정리하면 다음과 같다. 재귀로 구현하는 방법도 있으나, 이 글에서는 스택을 사용하는 방식으로 구현하였다.</p><pre><code class="language-txt">시작점을 스택에 넣는다.
이후의 과정을 스택이 비어있을 때까지 반복한다:
    스택에서 요소를 하나 pop한다.
    방금 pop한 정점이 아직 방문하지 않은 정점일 경우에만 아래 과정을 수행한다:
        현재 정점을 방문한 것으로 표시한다.
        현재 정점의 인접한 정점을 모두 스택에 push한다.
</code></pre><p>[<a href="#img-01">이미지 1</a>]을 예시로 DFS 탐색을 수행해보자. 시작점은 1이고 거리가 같은 정점이 여러 개 있을 때는 숫자가 작은 것부터 스택에 넣는다. 그러므로 실제 방문 순서는 숫자가 큰 것부터 방문하게 된다. 스택 push 순서를 바꾸면 작은 것부터 방문하도록 할 수 있다.</p><ol><li>탐색을 시작하기 전, 방문해야 할 정점을 저장할 빈 스택과 모든 정점의 방문 여부가 false로 표기된 방문 정점 리스트를 준비한다. 이 리스트는 배열을 써도 좋고, 벡터를 써도 좋다.<ul><li>스택의 내용 : <code class="language-plaintext highlighter-rouge">(비어있음)</code><li>방문 정점 리스트 : <code class="language-plaintext highlighter-rouge">{ 0, 0, 0, 0, 0, 0, 0, 0, 0 }</code> <em>// 편의상 true/false 대신 1/0으로 표기하며, 인덱스는 1부터 시작한다.</em></ul><li>탐색을 시작한다. 가장 먼저 시작점인 1을 스택에 넣는다.<ul><li>스택의 내용 : <code class="language-plaintext highlighter-rouge">{ 1 }</code><li>방문 정점 리스트 : <code class="language-plaintext highlighter-rouge">{ 0, 0, 0, 0, 0, 0, 0, 0, 0 }</code></ul><li>스택에 저장된 것을 하나 꺼낸다. 2번에서 1을 넣었으므로 1이 나온다. 1은 아직 방문하지 않은 정점이므로 방문한 것으로 표시하고, 1과 인접한 정점들을 스택에 차례대로 넣는다. 여기서는 2와 3을 넣으면 된다.<ul><li>스택의 내용 : <code class="language-plaintext highlighter-rouge">{ 3, 2 }</code><li>방문 정점 리스트 : <code class="language-plaintext highlighter-rouge">{ 1, 0, 0, 0, 0, 0, 0, 0, 0 }</code></ul><li>스택에 저장된 것을 하나 꺼내고(3이 나온다), 아직 방문하지 않은 정점이므로 해당 정점을 방문한 것으로 표시한다. 이후 3과 인접한 정점들을 스택에 넣는다. 1, 2, 6이 스택에 들어간다. 만약 이미 방문한 정점이 스택에서 나왔다면 아무것도 하지 않고 넘어간다.<ul><li>스택의 내용 : <code class="language-plaintext highlighter-rouge">{ 6, 2, 1, 2 }</code><li>방문 정점 리스트 : <code class="language-plaintext highlighter-rouge">{ 1, 0, 1, 0, 0, 0, 0, 0, 0 }</code></ul><li>위의 과정을 더이상 방문할 정점이 없을 때까지 수행한다.</ol><p>[<a href="#img-01">이미지 1</a>]의 그래프를 위와 같은 과정으로 탐색하면 방문하는 노드의 순서는 <code class="language-plaintext highlighter-rouge">{ 1, 3, 6, 9, 8, 5, 2, 4, 7 }</code>이다. 그림으로 그리면 아래와 같다. 노란색, 초록색, 파란색, 보라색 영역 내에 있는 정점을 순서대로 방문한다.</p><figure id="img-03"> <img data-src="/satinbower-legacy/assets/img/category-it/221106-3-graph.jpg" data-proofer-ignore><figcaption>[이미지 3] DFS 예시</figcaption></figure><p>코드로 구현해보자. BFS와 마찬가지로 시작점을 기준으로 각 정점까지의 거리를 구하는 코드를 작성하려고 했으나, DFS 탐색은 할 수 있지만 거리는 적절하게 구하지 못하는 결과가 나왔다. DFS 코드는 참고 자료 [<a id="body-ref-02" href="#tail-ref-02" title="DFS / BFS 예제 구현해보기 - python">2</a>]를 참고하여 작성했다. 출력 방식과 <a href="https://github.com/dapin1490/satinbower/blob/main/assets/files/code/BFS_DFS.h" target="_blank">전체 코드 링크</a>는 BFS와 같다.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">to_station</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span> <span class="c1">// 가장 가까운 station까지의 거리</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">adj</span><span class="p">;</span> <span class="c1">// 인접 노드</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// 각 인접 노드까지의 거리</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Graph</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">vertices</span><span class="p">;</span> <span class="c1">// 정점 수</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">graph</span><span class="p">;</span> <span class="c1">// 각 노드의 키값은 벡터의 인덱스로 대체</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">;</span> <span class="c1">// 방문 여부</span>

    <span class="kt">void</span> <span class="n">print_route</span><span class="p">();</span>

<span class="nl">public:</span>
    <span class="n">Graph</span><span class="p">(</span><span class="kt">int</span> <span class="n">vts</span><span class="p">);</span> <span class="c1">// 생성자</span>

    <span class="c1">// 반복으로 구현한 DFS</span>
    <span class="kt">void</span> <span class="n">DFS_by_iteration</span><span class="p">(</span><span class="kt">int</span> <span class="n">start_key</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">DFS_by_iteration</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">starts</span><span class="p">);</span> <span class="c1">// 시작점이 여러 개일 경우, 코드는 생략</span>

    <span class="c1">// 재귀로 구현한 DFS, 코드는 생략</span>
    <span class="kt">void</span> <span class="n">DFS_by_recursion</span><span class="p">(</span><span class="kt">int</span> <span class="n">start_key</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is_start</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">DFS_by_recursion</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">starts</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is_start</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span> <span class="c1">// 시작점이 여러 개일 경우</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">Graph</span><span class="o">::</span><span class="n">DFS_by_iteration</span><span class="p">(</span><span class="kt">int</span> <span class="n">start_key</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 루트(시작점)에서 시작</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// first는 방문해야 할 노드, second는 직전에 방문한 노드</span>

    <span class="n">s</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">start_key</span><span class="p">,</span> <span class="n">start_key</span><span class="p">);</span>
    <span class="n">graph</span><span class="p">[</span><span class="n">start_key</span><span class="p">].</span><span class="n">to_station</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 시작점은 station이므로 station까지의 거리가 0인데, 절차상 while 안에서 한번 방문하고 +1을 해야 하기 때문에 -1로 초기화</span>

    <span class="n">output_file</span> <span class="o">&lt;&lt;</span> <span class="s">"----------</span><span class="se">\n</span><span class="s">Station : "</span> <span class="o">&lt;&lt;</span> <span class="n">start_key</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">Search by DFS(iteration)</span><span class="se">\n\n</span><span class="s">"</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="c1">// 스택에서 pop</span>
        <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">curr</span><span class="p">.</span><span class="n">first</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// pop한 정점이 아직 방문하지 않은 것일 때</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">curr</span><span class="p">.</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 방문 표시</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">curr</span><span class="p">.</span><span class="n">first</span><span class="p">].</span><span class="n">to_station</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">curr</span><span class="p">.</span><span class="n">second</span><span class="p">].</span><span class="n">to_station</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 거리 합산</span>
            <span class="n">output_file</span> <span class="o">&lt;&lt;</span> <span class="s">"visit : "</span> <span class="o">&lt;&lt;</span> <span class="n">curr</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// 방문한 노드를 출력</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">curr</span><span class="p">.</span><span class="n">first</span><span class="p">].</span><span class="n">adj</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">graph</span><span class="p">[</span><span class="n">curr</span><span class="p">.</span><span class="n">first</span><span class="p">].</span><span class="n">adj</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">s</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">curr</span><span class="p">.</span><span class="n">first</span><span class="p">);</span> <span class="c1">// 인접 노드를 전부 스택에 추가</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 탐색을 끝낸 후 방문 여부 표시를 모두 지움</span>
    <span class="n">visited</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

    <span class="c1">// 탐색 결과 출력</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">print_route</span><span class="p">();</span>
    <span class="n">output_file</span> <span class="o">&lt;&lt;</span> <span class="s">"----------</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="bfs와-dfs의-시각적-비교"><span class="mr-2">BFS와 DFS의 시각적 비교</span><a href="#bfs와-dfs의-시각적-비교" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>지금까지 하나의 그래프를 BFS와 DFS로 탐색하며 두 알고리즘의 개념을 익혔다. 그렇지만 아무래도 두 개념은 헷갈리기가 쉽다. 그래서 위에서 사용한 두 알고리즘의 탐색 순서를 색깔로 표현한 이미지를 같이 붙여보았다. 왼쪽이 BFS, 오른쪽이 DFS이다. 그림의 가로 세로 방향보다는, 노란색으로 칠해진 시작점을 기준으로 어떻게 나아가는지를 보면 좋다. 시작점으로부터 짧게 겹겹이 나아가는 것이 BFS, 길고 깊게 나아가는 것이 DFS이다. 두 이미지 모두 탐색은 <code class="language-plaintext highlighter-rouge">노란색 → 초록색 → 파란색 → 보라색</code> 순서로 진행한다.</p><div style="text-align:center"><div style="width:50%; float:left"><figure> <img data-src="/satinbower-legacy/assets/img/category-it/221106-2-graph.jpg" data-proofer-ignore><figcaption style="text-align:center">[이미지 2] BFS 예시</figcaption></figure></div><div style="width:50%; float:left"><figure> <img data-src="/satinbower-legacy/assets/img/category-it/221106-3-graph.jpg" data-proofer-ignore><figcaption style="text-align:center">[이미지 3] DFS 예시</figcaption></figure></div></div><h2 id="참고-자료"><span class="mr-2">참고 자료</span><a href="#참고-자료" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>[<a id="tail-ref-01" href="#body-ref-01">1</a>] 『4차 산업혁명 시대의 이산수학』, 김대수 지음, 생능출판<br /> [<a id="tail-ref-02" href="#body-ref-02" title="">2</a>] DFS / BFS 예제 구현해보기 - python, <a href="https://nareunhagae.tistory.com/17" target="_blank">https://nareunhagae.tistory.com/17</a><br /> [3] C++ 파일 읽기/쓰기(C++ File Read/Write Example), <a href="https://jdm.kr/blog/170" target="_blank">https://jdm.kr/blog/170</a><br /> [4] C++에서 현재 시간 및 날짜 가져오기, <a href="https://www.techiedelight.com/ko/get-current-time-and-date-in-cpp/" target="_blank">https://www.techiedelight.com/ko/get-current-time-and-date-in-cpp/</a><br /> [5] C++ - localtime_s 사용 예, <a href="https://jacking75.github.io/C++_localtime_s/" target="_blank">https://jacking75.github.io/C++_localtime_s/</a><br /> [6] #pragma once 가 모든 문제를 해결해주진 않는다, <a href="https://teus.me/819" target="_blank">https://teus.me/819</a><br /> [7] [C언어][헤더 파일 중복 방지] #pragma once, #ifndef, <a href="https://blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;blogId=white_cap&amp;logNo=221002699804" target="_blank">https://blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;blogId=white_cap&amp;logNo=221002699804</a><br /> [8] [C, C++] #include &lt;헤더파일&gt;과 #include “헤더파일”의 차이, <a href="https://shjz.tistory.com/97" target="_blank">https://shjz.tistory.com/97</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/satinbower-legacy/categories/it/'>IT</a>, <a href='/satinbower-legacy/categories/algorithm/'>Algorithm</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/satinbower-legacy/tags/%EC%A7%80%EC%8B%9D/" class="post-tag no-text-decoration" >지식</a> <a href="/satinbower-legacy/tags/it/" class="post-tag no-text-decoration" >IT</a> <a href="/satinbower-legacy/tags/%EA%B3%BC%EC%A0%9C/" class="post-tag no-text-decoration" >과제</a> <a href="/satinbower-legacy/tags/bfs/" class="post-tag no-text-decoration" >BFS</a> <a href="/satinbower-legacy/tags/dfs/" class="post-tag no-text-decoration" >DFS</a> <a href="/satinbower-legacy/tags/%ED%83%90%EC%83%89/" class="post-tag no-text-decoration" >탐색</a> <a href="/satinbower-legacy/tags/%EA%B7%B8%EB%9E%98%ED%94%84/" class="post-tag no-text-decoration" >그래프</a> <a href="/satinbower-legacy/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/" class="post-tag no-text-decoration" >자료구조</a> <a href="/satinbower-legacy/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" class="post-tag no-text-decoration" >알고리즘</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.ko"> CC BY-NC-ND 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%5B%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%5D+BFS%EC%99%80+DFS+-+%EC%83%88%ED%8B%B4%EB%B0%94%EC%9A%B0%EC%96%B4&url=https%3A%2F%2Fdapin1490.github.io%2Fsatinbower-legacy%2Fposts%2Fit-bfs-and-dfs%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/satinbower-legacy/posts/backend-internet-230704/">[Backend] 인터넷이 뭔데</a><li><a href="/satinbower-legacy/posts/it-boj-1254/">[python] 백준 1254 팰린드롬 만들기</a><li><a href="/satinbower-legacy/posts/py-exe-release/">[python] GUI 프로그램 exe 만들고 배포하기, 소멸자와 로깅</a><li><a href="/satinbower-legacy/posts/daily-230617/">23년 1학기 14주 수업</a><li><a href="/satinbower-legacy/posts/chatgpt-230103/">Unity vs Unreal Engine</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/satinbower-legacy/tags/%EC%A7%80%EC%8B%9D/">지식</a> <a class="post-tag" href="/satinbower-legacy/tags/it/">IT</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%82%B4%EA%B0%80-%ED%95%B4%EB%83%84/">내가 해냄</a> <a class="post-tag" href="/satinbower-legacy/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/">문제풀이</a> <a class="post-tag" href="/satinbower-legacy/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> <a class="post-tag" href="/satinbower-legacy/tags/%EA%B3%BC%EC%A0%9C/">과제</a> <a class="post-tag" href="/satinbower-legacy/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/">프로젝트</a> <a class="post-tag" href="/satinbower-legacy/tags/leetcode/">LeetCode</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/">딥러닝</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/satinbower-legacy/posts/it-graph-dijkstra/"><div class="card-body"> <em class="small" data-ts="1669428900" data-df="YYYY-MM-DD" > 2022-11-26 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[자료구조] 그래프와 다익스트라</h3><div class="text-muted small"><p> 할 일 [과제] 이번 숙제는 다음 내용을 포함합니다. 1. 그래프 표현 방법(코드 중심)으로 설명합니다. (O) 2. 다익스트라 알고리즘을 설명하고, 코드를 구현합니다. (O) 3. (옵션) 백준 알고리즘 다음 문제를 풀어봅니다. (X) - 1753 최단경로 : 시간초과 - 1238 파티 - 1504 특정 최단 경로 - 1177 최소비용 구하...</p></div></div></a></div><div class="card"> <a href="/satinbower-legacy/posts/it-bellman-ford/"><div class="card-body"> <em class="small" data-ts="1670163600" data-df="YYYY-MM-DD" > 2022-12-04 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[자료구조] 벨만-포드 알고리즘</h3><div class="text-muted small"><p> 할 일 아래 내용을 포함하는 포트폴리오를 작성하고, 웹페이지 주소를 제출합니다. 1. 벨만포드 알고리즘 정리 (O) 2. Leet code 문제 풀이 : 743번 네트워크 딜레이 시간 (O) https://leetcode.com/problems/network-delay-time/ 2.1. 다익스트라를 이용한 풀이 (O) 2.2. 벨만포드를 이용한...</p></div></div></a></div><div class="card"> <a href="/satinbower-legacy/posts/it-priority-queue-heap/"><div class="card-body"> <em class="small" data-ts="1663157580" data-df="YYYY-MM-DD" > 2022-09-14 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[자료구조] 우선순위 큐와 힙</h3><div class="text-muted small"><p> 과제 우선순위 큐와 힙 내용 정리, C++를 이용한 우선순위큐 프로그래밍 방법 정리 백준 1966번 프린터 큐 풀이(필수) 백준 1655번 가운데를 말해요 풀이(선택) 우선순위 큐와 힙 내용 정리 힙도 자료구조다 힙 heap : 트리의 형태로 표현됨. 트리 : 사이클이 없는 그래프. 참고 : [자료구조] 트리, 참고 : [...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/satinbower-legacy/posts/daily-221029/" class="btn btn-outline-primary" prompt="이전 글"><p>22.10.29 단위 테스트 배우기</p></a> <a href="/satinbower-legacy/posts/knowledge-bone-and-muscle/" class="btn btn-outline-primary" prompt="다음 글"><p>근골격계에 대한 이해와 인체 움직임의 원리</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/dapin1490">dapin1490</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY-NC-ND 4.0) 라이선스에 따라 사용이 허가되었습니다.">일부 권리 보유</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/satinbower-legacy/tags/%EC%A7%80%EC%8B%9D/">지식</a> <a class="post-tag" href="/satinbower-legacy/tags/it/">IT</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%82%B4%EA%B0%80-%ED%95%B4%EB%83%84/">내가 해냄</a> <a class="post-tag" href="/satinbower-legacy/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/">문제풀이</a> <a class="post-tag" href="/satinbower-legacy/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> <a class="post-tag" href="/satinbower-legacy/tags/%EA%B3%BC%EC%A0%9C/">과제</a> <a class="post-tag" href="/satinbower-legacy/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/">프로젝트</a> <a class="post-tag" href="/satinbower-legacy/tags/leetcode/">LeetCode</a> <a class="post-tag" href="/satinbower-legacy/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/">딥러닝</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">새 버전의 콘텐츠를 사용할 수 있습니다.</p><button type="button" class="btn btn-primary" aria-label="Update"> 업데이트 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/satinbower-legacy/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/satinbower-legacy/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/satinbower-legacy/app.js"></script>
