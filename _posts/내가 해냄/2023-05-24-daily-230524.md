---
title: "23년 1학기 12주 수업"
author: dapin1490
date: 2023-05-24T00:00:00+09:00
categories: [내가 해냄]
tags: [내가 해냄]
render_with_liquid: false
---

<style>
  figure { text-align: center; }
</style>

## ToC
- [모빌리티서비스](#모빌리티서비스)
- [알고리즘](#알고리즘)
  - [처음 보는 문제 팀으로 해결하기](#처음-보는-문제-팀으로-해결하기)
  - [벨만포드](#벨만포드)
  - [다이나믹 프로그래밍](#다이나믹-프로그래밍)
    - [knapsack](#knapsack)
- [소프트웨어분석및설계](#소프트웨어분석및설계)
- [소프트웨어디자인패턴](#소프트웨어디자인패턴)

# 모빌리티서비스
휴강, 자습
* 라즈베리파이 SD카드 구울 때 ssh 허용하게 설정하고 시작하기
* nmap으로 라즈베리파이 ip 찾아서 연결하기 -> ip 찾는 건 되는데 라즈베리파이가 와이파이를 스스로 못잡아서 다시 구워야 함

# 알고리즘
## 처음 보는 문제 팀으로 해결하기
1. 각자 이해
2. 서로 도와서 해결
3. 완성본 비교
4. 합본(제일 좋은)
5. 최적화

-> 위 과정이 제대로 안 되었다면 혼자 하는 게 낫다.

## 벨만포드
generic 최단경로
1. 초기화: 모든 정점에 대해 거리를 무한으로 설정
2. 시작점은 0
3. 더이상 할 수 없을 때까지 다음을 반복
    1. 일정 기준에 따라 간선 선택
    2. Relax

Relax:  
`if (d[v] > d[u] + w(u, v))`  
    `d[v] = d[u] + w(u, v)`  
    `π[v] = u`

벨만포드
1. 초기화
2. `(정점 수 - 1)`만큼 반복
    1. 모든 간선에 대해
        1. Relax
3. 모든 간선에 대해
    1. `if (d[v] > d[u] + w(u, v))`  
        음수 사이클이 있음을 알림

`*` V는 정점, E는 간선

## 다이나믹 프로그래밍
과정
1. Define subprob: 부분 문제 정의
2. Guess: 부분 문제의 시간복잡도 추정
3. Ideate: 부분 문제 해결 시작
4. Rec + Memoi: 재귀가 필수는 아님
5. Solve Orig.Prob.: 원래 문제 해결

### knapsack
문제: 제한된 weight 내에서 주어진 item을 선택해 cost 최대화

문제 해결 과정
1. value for sufix `i` given knapsack size X
2. 2 choices: 넣는다 / 하나 빼고 넣는다
3. `DP[i, X] = max(DP[i+1, X], v_i + DP[i+1, X - S_i])`
4. `for i in n..0 AND X in 0..S` -> `Θ(nS)`
5. `DP[n, S]`

뭘 수업하는 건지 영 모르겠음

# 소프트웨어분석및설계
* 컴포넌트 vs 라이브러리
    * 컴포넌트는 실제 존재하는 실행 대상, 설계 단계에서 고려한다. 인터페이스+구현. 세부 구현을 숨기고 인터페이스에 의해 접근한다.
    * 소스코드가 있으면 라이브러리
* 인터페이스 클래스: 속성은 갖지 않고 오퍼레이션만 갖는다.
* deployment diagram: 컴포넌트를 어디에 어떻게 배치할 것인지 나타내는 다이어그램
* 클라이언트 컴포넌트: 주로 클라이언트 컴퓨터에서 작동, GUI.
* 서버 컴포넌트: 서버 컴퓨터에서 작동, 비즈니스 로직 및 데이터 관리.
* 컨테이너: 서버 컴포넌트가 안에 포함되어 통신함
    * 컴포넌트의 생성, 소멸, 생명주기 관리
    * 클라이언트-컴포넌트 사이 메시지 패싱 관리
    * 트랜잭션, 보안 등 기반 서비스 제공
* EJB(Enterprise Java Beans): 계층적 컴포넌트 아키텍처에 사용. 서버, 컨테이너, 홈 인터페이스, 리모트 인터페이스, 빈 클래스로 구성

# 소프트웨어디자인패턴
* Decorator 패턴
    * 간단한 이메일 알림 시스템을 만들고자 하는데, 알림을 보낼 앱이 많고 그 조합은 더 많다. 이들을 모두 자식 클래스로 생성하면 너무 많으니, 집합 관계를 이용해 하나의 wrapper가 여러 객체를 받아 합성된 행동을 하도록 하자.
    * 중심이 되는 객체에, 장식과 같은 부가적인 기능을 하나씩 입혀서 좀 더 목적에 어울리는 객체를 만드는 패턴
    * 컴포넌트(추상), 구체컴포넌트, 장식자(추상), 구체장식자. 구체컴포넌트와 장식자가 모두 컴포넌트를 상속 구현하고, 구체장식자는 장식자를 상속 구현한다. 장식자는 컴포넌트를 필드로 갖는다.
    * 컴포넌트는 기능 구현 및 장식의 가장 기본 바탕. 구체컴포넌트는 장식 없이 구현된 기본 바탕. 장식자는 컴포넌트와 같은 인터페이스를 가지며 장식자인 동시에 장식의 대상이 될 수 있다. 구체장식자는 장식자를 구현한다.
    * Composite 패턴과 같은 재귀 구조.
    * 내용 변경 없이 기능 추가 가능, 단순한 장식의 조합으로 다양한 기능 구현 가능. ``java,io`` 패키지에 Decorator 패턴 사용됨. 자잘한 구체장식자를 모두 구현해야 하므로 작은 클래스가 많아질 수 있다.
    * 도로 표시 방법 조합하기 예제
        * 기본 기능: 도로를 선으로 표시
        * 추가 기능: 내비게이션 SW에 따라 도로의 차선을 표시

